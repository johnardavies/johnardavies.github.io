<!DOCTYPE html>
<html lang="en" dir="auto">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Cloud 7: Building an API with Lambda, Docker and CloudFormation | John&#39;s Site</title>
<meta name="keywords" content="technical, digital, cloud">
<meta name="description" content="Cloud 7: Building an API with Lambda, Docker and CloudFormation
Antony Gormley&rsquo;s &lsquo;Bind&rsquo; at White Cube
Managing Python dependencies with lambda functions in AWS
I recently used a serverless approach to build an API for a project I was working on. Each API call triggered a lambda function to process the data from the call and the returned a response. This had the advantage of not having to maintain a constantly running server costing money when unused. However, the Python dependencies I used in this case pandas, numpy (and associated C complier) were not completely straightforward to include in the Amazon Web Services (AWS) lambdas framework I was using.">
<meta name="author" content="John Davies">
<link rel="canonical" href="http://johnardavies.github.io/technical/api_lambda/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css" integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw&#43;W8mWdq36u97PLc=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://johnardavies.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://johnardavies.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://johnardavies.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://johnardavies.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://johnardavies.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://johnardavies.github.io/technical/api_lambda/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-YJ821LVT08"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-YJ821LVT08');
        }
      </script><meta property="og:url" content="https://johnardavies.github.io/technical/api_lambda/">
  <meta property="og:site_name" content="John&#39;s Site">
  <meta property="og:title" content="Cloud 7: Building an API with Lambda, Docker and CloudFormation">
  <meta property="og:description" content="Cloud 7: Building an API with Lambda, Docker and CloudFormation Antony Gormley’s ‘Bind’ at White Cube
Managing Python dependencies with lambda functions in Amazon Web Services (AWS)
I recently used a serverless approach to build an API for a project. Each API call triggered a lambda function to process the data from the call and then returned a response. This had the advantage of not having to maintain a constantly running server costing money. However, the Python dependencies involved, in this case pandas, numpy (and associated C compiler), were not completely straightforward to include in the AWS lambda framework I was using.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="technical">
    <meta property="article:published_time" content="2024-12-27T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-12-27T00:00:00+00:00">
    <meta property="article:tag" content="Technical">
    <meta property="article:tag" content="Digital">
    <meta property="article:tag" content="Cloud">
    <meta property="og:image" content="https://johnardavies.github.io/API_image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://johnardavies.github.io/API_image.png">
<meta name="twitter:title" content="Cloud 7: Building an API with Lambda, Docker and CloudFormation">
<meta name="twitter:description" content="Cloud 7: Building an API with Lambda, Docker and CloudFormation
Antony Gormley&rsquo;s &lsquo;Bind&rsquo; at White Cube
Managing Python dependencies with lambda functions in Amazon Web Services (AWS)
I recently used a serverless approach to build an API for a project. Each API call triggered a lambda function to process the data from the call and then returned a response. This had the advantage of not having to maintain a constantly running server costing money. However, the Python dependencies involved, in this case pandas, numpy (and associated C compiler), were not completely straightforward to include in the AWS lambda framework I was using.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Technicals",
      "item": "https://johnardavies.github.io/technical/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Cloud 7: Building an API with Lambda, Docker and CloudFormation",
      "item": "https://johnardavies.github.io/technical/api_lambda/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Cloud 7: Building an API with Lambda, Docker and CloudFormation",
  "name": "Cloud 7: Building an API with Lambda, Docker and CloudFormation",
  "description": "Cloud 7: Building an API with Lambda, Docker and CloudFormation Antony Gormley\u0026rsquo;s \u0026lsquo;Bind\u0026rsquo; at White Cube\nManaging Python dependencies with lambda functions in Amazon Web Services (AWS)\nI recently used a serverless approach to build an API for a project. Each API call triggered a lambda function to process the data from the call and then returned a response. This had the advantage of not having to maintain a constantly running server costing money. However, the Python dependencies involved, in this case pandas, numpy (and associated C compiler), were not completely straightforward to include in the AWS lambda framework I was using.\n",
  "keywords": [
    "technical", "digital", "cloud"
  ],
  "articleBody": "Cloud 7: Building an API with Lambda, Docker and CloudFormation Antony Gormley’s ‘Bind’ at White Cube\nManaging Python dependencies with lambda functions in Amazon Web Services (AWS)\nI recently used a serverless approach to build an API for a project. Each API call triggered a lambda function to process the data from the call and then returned a response. This had the advantage of not having to maintain a constantly running server costing money. However, the Python dependencies involved, in this case pandas, numpy (and associated C compiler), were not completely straightforward to include in the AWS lambda framework I was using.\nThere is a way to deal with this by installing the dependencies in a virtual environment, zipping it and uploading it to S3 for the lambda to access (This is described in the first reference below). However, there are size limits on what can be packaged at one go. I therefore ended up using a Docker image to install the packages. The image is then run by a lambda function that is linked to API calls. For future reference I am writing this up here with a simple example of installing dependencies for this kind of use case.\nThe following assumes some knowledge of Docker and AWS, and that the AWS command line interface (CLI) is set up with the permissions to launch the various services.\nA schematic of the components used is given below: The project setup is that the Dockerfile we want to build the image and Python script (lambda_handler.py) we want the API to run via the lambda are included in a folder called container_folder with the requirements.txt file specifying the dependencies. The CloudFormation yaml file api-lambda-example.yml is used to specify and launch the components of the API. The files are available from https://github.com/johnardavies/lambda_api_example.\nStructure of the post:\n1. Creating the Docker image with the dependencies\n2. The script the API runs\n3. The CloudFormation template that creates the API Stack\n4. Generating an API key that rate limits the API\n5. Launching the API\n6. Calling the API\n1. Creating the Docker image with the dependencies The first stage is to build a Docker image with the Python script and its dependencies that it runs. The Dockerfile below uses a base Python image. The script we want it to run (lambda_handler.py described in the next section) is copied to a folder called function on the image. The requirements.txt file which specifies the dependencies is copied into the folder and used to install them. The Dockerfile then copies the folder to a smaller Python image. In this image it installs a C and C++ compiler. As we are not using an AWS image we have to install the awslambdaric package to allow AWS Lambda to run the image. The API call triggers the lambda which runs the container image. The container then runs the Python script. The Dockerfile is described in more detail in the second reference of this post.\n# Define custom function directory ARG FUNCTION_DIR=\"/function\" FROM python:3.10 AS build-image # Include global arg in this stage of the build ARG FUNCTION_DIR # Copy function code RUN mkdir -p ${FUNCTION_DIR} COPY . ${FUNCTION_DIR} COPY requirements.txt . # Install the function's dependencies RUN pip install \\ --target ${FUNCTION_DIR} \\ -r requirements.txt # Use a slim version of the base Python image to reduce the final image size FROM python:3.10-slim # Include global arg in this stage of the build ARG FUNCTION_DIR # Set working directory to function root directory WORKDIR ${FUNCTION_DIR} # Copy in the built dependencies COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR} # Install a C AND C++ compiler RUN apt-get update \u0026\u0026 \\ apt-get install -y zip gcc g++ \u0026\u0026 \\ rm -rf /var/lib/apt/lists/* # Set runtime interface client as default command for the container runtime ENTRYPOINT [ \"/usr/local/bin/python\", \"-m\", \"awslambdaric\" ] # Pass the name of the function handler as an argument to the runtime CMD [ \"lambda_function.handler\" ] To build the image specified by the Dockerfile run the command outside the container_folder. Here we tag the image as api_stack.\ndocker build --tag api_stack container_folder/ To obtain the id of the resulting Docker image we then run:\ndocker images Having built the container image we then authenticate with the AWS Elastic Container Registry (ECR) to store it. To do this we run the following where xxxxxx is the AWS Account ID. We also specify a region (here eu-west-2) which also appears in the container registry file path.\naws ecr get-login-password --region eu-west-2 | docker login --username AWS --password-stdin xxxxxx.dkr.ecr.eu-west-2.amazonaws.com If this is successful, then Login Succeeded will be returned. We then tag the container to give it a name. Here the image is identified by the id 7d990bc03f26 and given the name api_example_container.\ndocker tag 7d990bc03f26 xxxxxxx.dkr.ecr.eu-west-2.amazonaws.com/api_example_container We then create a repository in ECR to hold the container image.\naws ecr create-repository \\ --repository-name api_example_container \\ --image-scanning-configuration scanOnPush=true \\ --region eu-west-2 We then push the image to the container registry so that CloudFormation can access it:\ndocker push xxxxxxx.dkr.ecr.eu-west-2.amazonaws.com/api_example_container:latest 2. The script the API runs In this example the script we want the lambda to run has a very simple form which takes an input text string from the API call. The script then imports the pandas and numpy packages and prints the text input with the pandas and numpy versions in a json format. The function is called handler and is saved in the Python script lambda_function.py shown below which is copied into the image when it is built.\nimport sys import numpy as np import pandas as pd import json def handler(event, context): \"\"\"Function that takes input string and imports numpy and pandas returning their versions as a json\"\"\" query_params = event.get(\"queryStringParameters\", {}) input = query_params.get(\"input\", \"world\") # Return the result as JSON return { \"statusCode\": 200, \"body\": json.dumps( { \"hello\": str(input), \"numpy version\": str(np.__version__), \"pandas version\": str(pd.__version__), } ), } 3. The CloudFormation template that creates the API Stack The API is launched from the CloudFormation template api-lambda-example.yml which specifies the services that are used and the relationship between them. We pass two parameters to the template when launching the stack to generate the API. The first is the Uniform Resource identifier (URI) of the container that we are running. The second is the StageName which forms part of the endpoint and is typically used to distinguish between different versions of the API, for example a production or development version (prod or dev).\nDescription: A CloudFormation template that creates an API that runs a container. The API is rate limited API with an API key. Parameters: ECRRepositoryUri: Type: String Description: The URI of the Docker image in Amazon ECR (e.g., .dkr.ecr..amazonaws.com/:). StageName: Type: String Description: Name of API stage. Resources: # API Gateway ApiGateway: Type: 'AWS::ApiGateway::RestApi' Properties: Name: 'ApiExample' ApiKeySourceType: HEADER # API Resource ApiResource: Type: 'AWS::ApiGateway::Resource' Properties: ParentId: !GetAtt ApiGateway.RootResourceId PathPart: 'installer' RestApiId: !Ref ApiGateway # The lambda function which is linked to the container image in the Elastic Container Registry ExampleAPIDependencies: Type: \"AWS::Lambda::Function\" Properties: FunctionName: 'ExampleAPIDependencies' Role: !GetAtt LambdaExecutionRole.Arn Code: ImageUri: !Ref ECRRepositoryUri PackageType: \"Image\" Architectures: - 'arm64' Timeout: 30 MemorySize: 500 # Gives the API Gateway permission to call the lambda function ExampleAPIDependencies LambdaApiGatewayPermission: Type: 'AWS::Lambda::Permission' Properties: Action: 'lambda:InvokeFunction' FunctionName: !Ref ExampleAPIDependencies Principal: 'apigateway.amazonaws.com' # Lambda Execution Role LambdaExecutionRole: Type: 'AWS::IAM::Role' Properties: AssumeRolePolicyDocument: Version: '2012-10-17' Statement: - Effect: 'Allow' Principal: Service: 'lambda.amazonaws.com' Action: 'sts:AssumeRole' Policies: - PolicyName: 'LambdaBasicExecution' PolicyDocument: Version: '2012-10-17' Statement: - Effect: 'Allow' Action: - 'logs:CreateLogGroup' - 'logs:CreateLogStream' - 'logs:PutLogEvents' Resource: '*' # API Method ApiMethod: Type: 'AWS::ApiGateway::Method' Properties: HttpMethod: 'GET' ResourceId: !Ref ApiResource RestApiId: !Ref ApiGateway AuthorizationType: 'NONE' ApiKeyRequired: true Integration: Type: AWS_PROXY IntegrationHttpMethod: 'POST' Uri: !Sub 'arn:aws:apigateway:eu-west-2:lambda:path/2015-03-31/functions/${ExampleAPIDependencies.Arn}/invocations' # API Deployment linked to a stage ApiDeployment: Type: 'AWS::ApiGateway::Deployment' DependsOn: ApiMethod # Ensures the deployment happens after the method is created Properties: RestApiId: !Ref ApiGateway StageName: !Sub '${StageName}' # Usage Plan UsagePlan: Type: 'AWS::ApiGateway::UsagePlan' DependsOn: ApiDeployment # Ensures the usage plan is created after the deployment Properties: UsagePlanName: 'MyUsagePlan' ApiStages: - ApiId: !Ref ApiGateway Stage: !Sub '${StageName}' Throttle: BurstLimit: 100 RateLimit: 50 Quota: Limit: 1000 Period: MONTH # API Key ApiKey: Type: 'AWS::ApiGateway::ApiKey' Properties: Enabled: true Name: 'APIExampleKey' # Usage Plan Key UsagePlanKey: Type: 'AWS::ApiGateway::UsagePlanKey' Properties: KeyId: !Ref ApiKey KeyType: 'API_KEY' UsagePlanId: !Ref UsagePlan The section below creates the API path installer. It then creates the lambda function ExampleAPIDependencies which runs container image located in the image URI passed to the CloudFormation stack. As the container was built on an Apple Silicon Mac the architecture is specified as arm64. The lambda times out after 30 seconds and has a maximum memory of 500 Megabytes. The API gateway is then given permission to invoke the lambda function.\n# API Resource ApiResource: Type: 'AWS::ApiGateway::Resource' Properties: ParentId: !GetAtt ApiGateway.RootResourceId PathPart: 'installer' RestApiId: !Ref ApiGateway # The lambda function which is linked to the container image in the Elastic Container Registry ExampleAPIDependencies: Type: \"AWS::Lambda::Function\" Properties: FunctionName: 'ExampleAPIDependencies' Role: !GetAtt LambdaExecutionRole.Arn Code: ImageUri: !Ref ECRRepositoryUri PackageType: \"Image\" Architectures: - 'arm64' Timeout: 30 MemorySize: 500 # Gives the API Gateway permission to call the lambda function ExampleAPIDependencies LambdaApiGatewayPermission: Type: 'AWS::Lambda::Permission' Properties: Action: 'lambda:InvokeFunction' FunctionName: !Ref ExampleAPIDependencies Principal: 'apigateway.amazonaws.com' The lambda function is given permission to write to logs helping to monitor what happens when it is called. The ApiMethod specifies a GET command to call the API and that an API key is required. API deployment specifies when deployment happens.\n# Lambda Execution Role LambdaExecutionRole: Type: 'AWS::IAM::Role' Properties: AssumeRolePolicyDocument: Version: '2012-10-17' Statement: - Effect: 'Allow' Principal: Service: 'lambda.amazonaws.com' Action: 'sts:AssumeRole' Policies: - PolicyName: 'LambdaBasicExecution' PolicyDocument: Version: '2012-10-17' Statement: - Effect: 'Allow' Action: - 'logs:CreateLogGroup' - 'logs:CreateLogStream' - 'logs:PutLogEvents' Resource: '*' # API Method ApiMethod: Type: 'AWS::ApiGateway::Method' Properties: HttpMethod: 'GET' ResourceId: !Ref ApiResource RestApiId: !Ref ApiGateway AuthorizationType: 'NONE' ApiKeyRequired: true Integration: Type: AWS_PROXY IntegrationHttpMethod: 'POST' Uri: !Sub 'arn:aws:apigateway:eu-west-2:lambda:path/2015-03-31/functions/${ExampleAPIDependencies.Arn}/invocations' # API Deployment linked to a stage ApiDeployment: Type: 'AWS::ApiGateway::Deployment' DependsOn: ApiMethod # Ensures the deployment happens after the method is created Properties: RestApiId: !Ref ApiGateway StageName: !Sub '${StageName}' 4. Generating an API key that rate limits the API To make it harder for someone unwanted to hit the API endpoint a large number of times racking up a bill, the CloudFormation template includes a rate limit plan. In the template an API key is generated here called ‘APIExampleKey’ which is then attached to the plan. This does not ensure that the identity of the user of the API key is authenticated which would require additional steps.\n# Usage Plan UsagePlan: Type: 'AWS::ApiGateway::UsagePlan' DependsOn: ApiDeployment # Ensures the usage plan is created after the deployment Properties: UsagePlanName: 'MyUsagePlan' ApiStages: - ApiId: !Ref ApiGateway Stage: 'prod' Throttle: BurstLimit: 100 RateLimit: 50 Quota: Limit: 1000 Period: MONTH # API Key ApiKey: Type: 'AWS::ApiGateway::ApiKey' Properties: Enabled: true Name: 'APIExampleKey' # Usage Plan Key UsagePlanKey: Type: 'AWS::ApiGateway::UsagePlanKey' Properties: KeyId: !Ref ApiKey KeyType: 'API_KEY' UsagePlanId: !Ref UsagePl` 5. Launching the API To create the stack and generate the API (here called ExampleApiStack) we run the following from the command line (The xxxxxxxxxxx being replaced by the AWS account id):\naws cloudformation create-stack --stack-name ExampleApiStack \\ --template-body file://api-lambda-example.yml \\ --region eu-west-2 \\ --capabilities CAPABILITY_IAM \\ --parameters \\ ParameterKey=ECRRepositoryUri,ParameterValue=xxxxxxxxxxx.dkr.ecr.eu-west-2.amazonaws.com/api_example_container:latest \\ ParameterKey=StageName,ParameterValue=‘prod’ Here the container that the lambda runs and the StageName (here prod) are passed to the template as parameters.\nTo obtain the stack info:\naws cloudformation describe-stacks --stack-name ExampleApiStack An example of the output from this is below. Some account specific information has been removed. 6. Calling the API To get the information on the API endpoint that the CloudFormation stack has generated:\naws apigateway get-rest-apis An example of what the command produces is shown below: This gives us the API id which we insert into the general endpoint form that the stack produces (shown below) to call it.\nhttps://{api_id}.execute-api.eu-west-2.amazonaws.com/prod/installer?input={text_passed_to_api} In this example the api_id is 8ijgbd265k. The API key value can be obtained from the API Gateway page on the AWS console. To test the API works we curl the endpoint passing the API key in the header -H \"x-api-key: and the input text in the endpoint (Some formatting issues initially threw the curl command on a Mac: Having curly quotes “ rather than straight quotes \" and having whitespace after the \\.) :\ncurl -X GET \"https://8ijgbd265k.execute-api.eu-west-2.amazonaws.com/prod/installer?input=world\" \\ -H \"x-api-key: pqsJ6ObKmx1SxAN0cTlUCHKubRDxH2d5UPBeRsej\" This produces the return:\n{\"hello\": \"world\", \"numpy version\": \"2.2.1\", \"pandas version\": \"2.2.3\"} An example of what this looks like in the terminal is: To remove the API and its stack when it is no longer needed:\naws cloudformation delete-stack --stack-name ExampleApiStack A variant of the usual Cloud warning At time of writing the AWS Lambda free tier in the eu-west-2 region includes one million free requests per month and beyond that it costs $0.20 per 1M requests see https://aws.amazon.com/lambda/pricing/. This means that, in principle, serverless should cost very little as long as the number of requests is low. In the example here it is probably significantly cheaper than having a virtual machine continuously running to handle the API calls. However, in the event of large number of requests, perhaps by someone maliciously calling the API many times and/or any data processing incurring high storage costs this might not be true. Until AWS implements the budget cap that everyone wants, as always, the costs of cloud services should be monitored and services turned off when not used to avoid incurring unwanted costs.\nReferences: AWS guidance on working with .zip file archives for Python Lambda functions https://docs.aws.amazon.com/lambda/latest/dg/python-package.html\nAWS guidance on deploying Python Lambda functions with container images https://docs.aws.amazon.com/lambda/latest/dg/python-image.html#python-image-clients\nAWS guidance on creating and configuring API keys and usage plans with AWS CloudFormation https://docs.aws.amazon.com/apigateway/latest/developerguide/api-key-usage-plan-cfn.html\nMichael Hart (2020), Using container images with AWS Lambda https://hichaelmart.medium.com/using-container-images-with-aws-lambda-7ffbd23697f1\nPrevious Cloud posts Cloud 1: Introduction to launching a Virtual Machine in the Cloud\nCloud 2: Getting started with using a Virtual Machine in the Cloud\nCloud 3: Docker and Jupyter notebooks in the Cloud\nCloud 4: Using Serverless\nCloud 5: Introduction to deploying an app with simple CI/CD\nCloud 6: Introduction to Infrastructure as Code using CloudFormation\n",
  "wordCount" : "2321",
  "inLanguage": "en",
  "image":"https://johnardavies.github.io/API_image.png","datePublished": "2024-12-27T00:00:00Z",
  "dateModified": "2024-12-27T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "John Davies"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://johnardavies.github.io/technical/api_lambda/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "John's Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://johnardavies.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://johnardavies.github.io/" accesskey="h" title="John&#39;s Site (Alt + H)">John&#39;s Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://johnardavies.github.io/creative_industries" title="creative industries">
                    <span>creative industries</span>
                </a>
            </li>
            <li>
                <a href="https://johnardavies.github.io/other_data_projects" title="other data projects">
                    <span>other data projects</span>
                </a>
            </li>
            <li>
                <a href="https://johnardavies.github.io/talks/" title="talks">
                    <span>talks</span>
                </a>
            </li>
            <li>
                <a href="https://johnardavies.github.io/technical/" title="technical">
                    <span>technical</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Cloud 7: Building an API with Lambda, Docker and CloudFormation
    </h1>
    <div class="post-meta"><span title='2024-12-27 00:00:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;John Davies

</div>
  </header> 
<figure class="entry-cover"><img loading="eager" src="https://johnardavies.github.io/API_image.png" alt="">
        
</figure>
  <div class="post-content"><h3 id="cloud-7-building-an-api-with-lambda-docker-and-cloudformation">Cloud 7: Building an API with Lambda, Docker and CloudFormation<a hidden class="anchor" aria-hidden="true" href="#cloud-7-building-an-api-with-lambda-docker-and-cloudformation">#</a></h3>
<p><a href="https://www.whitecube.com/gallery-exhibitions/antony-gormley-body-politic">Antony Gormley&rsquo;s &lsquo;Bind&rsquo; at White Cube</a></p>
<p><strong>Managing Python dependencies with lambda functions in Amazon Web Services (AWS)</strong><br>
I recently used a serverless approach to build an API for a project. Each API call triggered a lambda function to process the data from the call and then returned a response. This had the advantage of not having to maintain a constantly running server costing money. However, the Python dependencies involved, in this case pandas, numpy (and associated C compiler), were not completely straightforward to include in the AWS lambda framework I was using.</p>
<p>There is a way to deal with this by installing the dependencies in a virtual environment, zipping it and uploading it to S3 for the lambda to access (This is described in the first reference below). However, there are size limits on what can be packaged at one go. I therefore ended up using a Docker image to install the packages. The image is then run by a lambda function that is linked to API calls. For future reference I am writing this up here with a simple example of installing dependencies for this kind of use case.</p>
<p>The following assumes some knowledge of Docker and AWS, and that the AWS command line interface (CLI) is set up with the permissions to launch the various services.</p>
<p>A schematic of the components used is given below:
<img alt="api_schematic" loading="lazy" src="https://johnardavies.github.io/api_schematic.png">
The project setup is that the <code>Dockerfile</code> we want to build the image and Python script (<code>lambda_handler.py</code>) we want the API to run via the lambda are included in a folder called <code>container_folder</code> with the <code>requirements.txt</code> file specifying the dependencies. The CloudFormation yaml file <code>api-lambda-example.yml</code> is used to specify and launch the components of the API. The files are available from <a href="https://github.com/johnardavies/lambda_api_example">https://github.com/johnardavies/lambda_api_example</a>.</p>
<p>Structure of the post:</p>
<p><strong>1. Creating the Docker image with the dependencies</strong><br>
<strong>2. The script the API runs</strong><br>
<strong>3. The CloudFormation template that creates the API Stack</strong><br>
<strong>4. Generating an API key that rate limits the API</strong><br>
<strong>5. Launching the API</strong><br>
<strong>6. Calling the API</strong></p>
<h3 id="1-creating-the-docker-image-with-the-dependencies">1. Creating the Docker image with the dependencies<a hidden class="anchor" aria-hidden="true" href="#1-creating-the-docker-image-with-the-dependencies">#</a></h3>
<p>The first stage is to build a Docker image with the Python script and its dependencies that it runs. The Dockerfile below uses a base Python image. The script we want it to run (<code>lambda_handler.py</code> described in the next section) is copied to a folder called <code>function</code> on the image. The requirements.txt file which specifies the dependencies is copied into the folder and used to install them. The Dockerfile then copies the folder to a smaller Python image. In this image it installs a C and C++ compiler. As we are not using an AWS image we have to install the <code>awslambdaric</code> package to allow AWS Lambda to run the image. The API call triggers the lambda which runs the container image. The container then runs the Python script. The Dockerfile is described in more detail in the second reference of this post.</p>
<pre tabindex="0"><code># Define custom function directory
ARG FUNCTION_DIR=&#34;/function&#34;

FROM python:3.10 AS build-image

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Copy function code
RUN mkdir -p ${FUNCTION_DIR}
COPY . ${FUNCTION_DIR}

COPY requirements.txt .

# Install the function&#39;s dependencies
RUN pip install \
    --target ${FUNCTION_DIR} \
        -r requirements.txt

# Use a slim version of the base Python image to reduce the final image size
FROM python:3.10-slim

# Include global arg in this stage of the build
ARG FUNCTION_DIR
# Set working directory to function root directory
WORKDIR ${FUNCTION_DIR}

# Copy in the built dependencies
COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR}

# Install a C AND C++ compiler
RUN apt-get update &amp;&amp; \
    apt-get install -y zip gcc g++ &amp;&amp; \
    rm -rf /var/lib/apt/lists/*


# Set runtime interface client as default command for the container runtime
ENTRYPOINT [ &#34;/usr/local/bin/python&#34;, &#34;-m&#34;, &#34;awslambdaric&#34; ]
# Pass the name of the function handler as an argument to the runtime
CMD [ &#34;lambda_function.handler&#34; ]
</code></pre><p>To build the image specified by the Dockerfile run the command outside the container_folder. Here we tag the image as api_stack.</p>
<pre tabindex="0"><code>docker build --tag api_stack container_folder/
</code></pre><p>To obtain the id of the resulting Docker image we then run:</p>
<pre tabindex="0"><code>docker images
</code></pre><p>Having built the container image we then authenticate with the AWS Elastic Container Registry (ECR) to store it. To do this we run the following where xxxxxx is the AWS Account ID. We also specify a region (here eu-west-2) which also appears in the container registry file path.</p>
<pre tabindex="0"><code>aws ecr get-login-password --region eu-west-2 | docker login --username AWS --password-stdin xxxxxx.dkr.ecr.eu-west-2.amazonaws.com
</code></pre><p>If this is successful, then <code>Login Succeeded</code> will be returned. We then tag the container to give it a name. Here the image is identified by the id 7d990bc03f26 and given the name <code>api_example_container</code>.</p>
<pre tabindex="0"><code>docker tag 7d990bc03f26 xxxxxxx.dkr.ecr.eu-west-2.amazonaws.com/api_example_container
</code></pre><p>We then create a repository in ECR to hold the container image.</p>
<pre tabindex="0"><code>aws ecr create-repository \
   --repository-name api_example_container \
   --image-scanning-configuration scanOnPush=true \
   --region eu-west-2
</code></pre><p>We then push the image to the container registry so that CloudFormation can access it:</p>
<pre tabindex="0"><code>docker push xxxxxxx.dkr.ecr.eu-west-2.amazonaws.com/api_example_container:latest
</code></pre><h3 id="2-the-script-the-api-runs">2. The script the API runs<a hidden class="anchor" aria-hidden="true" href="#2-the-script-the-api-runs">#</a></h3>
<p>In this example the script we want the lambda to run has a very simple form which takes an input text string from the API call. The script then imports the pandas and numpy packages and prints the text input with the pandas and numpy versions in a json format. The function is called handler and is saved in the Python script <code>lambda_function.py</code> shown below which is copied into the image when it is built.</p>
<pre tabindex="0"><code>import sys
import numpy as np
import pandas as pd
import json


def handler(event, context):
    &#34;&#34;&#34;Function that takes input string and imports numpy and pandas returning their versions as a json&#34;&#34;&#34;
    query_params = event.get(&#34;queryStringParameters&#34;, {})
    input = query_params.get(&#34;input&#34;, &#34;world&#34;)

    # Return the result as JSON
    return {
        &#34;statusCode&#34;: 200,
        &#34;body&#34;: json.dumps(
            {
                &#34;hello&#34;: str(input),
                &#34;numpy version&#34;: str(np.__version__),
                &#34;pandas version&#34;: str(pd.__version__),
            }
        ),
    }
</code></pre><h3 id="3--the-cloudformation-template-that-creates-the-api-stack">3.  The CloudFormation template that creates the API Stack<a hidden class="anchor" aria-hidden="true" href="#3--the-cloudformation-template-that-creates-the-api-stack">#</a></h3>
<p>The API is launched from the CloudFormation template <code>api-lambda-example.yml</code> which specifies the services that are used and the relationship between them. We pass two parameters to the template when launching the stack to generate the API. The first is the Uniform Resource identifier (URI) of the container that we are running. The second is the StageName which forms part of the endpoint and is typically used to distinguish between different versions of the API, for example a production or development version (prod or dev).</p>
<pre tabindex="0"><code>Description: A CloudFormation template that creates an API that runs a container. The API is rate limited API with an API key. 

Parameters:
  ECRRepositoryUri:
    Type: String
    Description: The URI of the Docker image in Amazon ECR (e.g., &lt;account-id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/&lt;repository-name&gt;:&lt;tag&gt;).

  StageName:
    Type: String
    Description: Name of API stage.

Resources:
  
  # API Gateway
  ApiGateway:
    Type: &#39;AWS::ApiGateway::RestApi&#39;
    Properties:
      Name: &#39;ApiExample&#39;
      ApiKeySourceType: HEADER

  # API Resource
  ApiResource:
    Type: &#39;AWS::ApiGateway::Resource&#39;
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: &#39;installer&#39;
      RestApiId: !Ref ApiGateway
      
  # The lambda function which is linked to the container image in the Elastic Container Registry
  ExampleAPIDependencies: 
    Type: &#34;AWS::Lambda::Function&#34;
    Properties:
      FunctionName: &#39;ExampleAPIDependencies&#39;
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ImageUri: !Ref ECRRepositoryUri
      PackageType: &#34;Image&#34;
      Architectures: 
        - &#39;arm64&#39;
      Timeout: 30
      MemorySize: 500

  # Gives the API Gateway permission to call the lambda function ExampleAPIDependencies
  LambdaApiGatewayPermission:
    Type: &#39;AWS::Lambda::Permission&#39;
    Properties:
      Action: &#39;lambda:InvokeFunction&#39;
      FunctionName: !Ref ExampleAPIDependencies
      Principal: &#39;apigateway.amazonaws.com&#39;

  # Lambda Execution Role
  LambdaExecutionRole:
    Type: &#39;AWS::IAM::Role&#39;
    Properties:
      AssumeRolePolicyDocument:
        Version: &#39;2012-10-17&#39;
        Statement:
          - Effect: &#39;Allow&#39;
            Principal:
              Service: &#39;lambda.amazonaws.com&#39;
            Action: &#39;sts:AssumeRole&#39;
      Policies:
        - PolicyName: &#39;LambdaBasicExecution&#39;
          PolicyDocument:
            Version: &#39;2012-10-17&#39;
            Statement:
              - Effect: &#39;Allow&#39;
                Action:
                  - &#39;logs:CreateLogGroup&#39;
                  - &#39;logs:CreateLogStream&#39;
                  - &#39;logs:PutLogEvents&#39;
                Resource: &#39;*&#39;
    
  # API Method
  ApiMethod:
    Type: &#39;AWS::ApiGateway::Method&#39;
    Properties:
      HttpMethod: &#39;GET&#39;
      ResourceId: !Ref ApiResource
      RestApiId: !Ref ApiGateway
      AuthorizationType: &#39;NONE&#39;
      ApiKeyRequired: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: &#39;POST&#39;
        Uri: !Sub &#39;arn:aws:apigateway:eu-west-2:lambda:path/2015-03-31/functions/${ExampleAPIDependencies.Arn}/invocations&#39;
  
  # API Deployment linked to a stage
  ApiDeployment:
    Type: &#39;AWS::ApiGateway::Deployment&#39;
    DependsOn: ApiMethod  # Ensures the deployment happens after the method is created
    Properties:
      RestApiId: !Ref ApiGateway
      StageName: !Sub &#39;${StageName}&#39;

  # Usage Plan
  UsagePlan:
    Type: &#39;AWS::ApiGateway::UsagePlan&#39;
    DependsOn: ApiDeployment  # Ensures the usage plan is created after the deployment
    Properties:
      UsagePlanName: &#39;MyUsagePlan&#39;
      ApiStages:
        - ApiId: !Ref ApiGateway
          Stage: !Sub &#39;${StageName}&#39;
      Throttle:
        BurstLimit: 100
        RateLimit: 50
      Quota:
        Limit: 1000
        Period: MONTH

  # API Key
  ApiKey:
    Type: &#39;AWS::ApiGateway::ApiKey&#39;
    Properties:
      Enabled: true
      Name: &#39;APIExampleKey&#39;

  # Usage Plan Key
  UsagePlanKey:
    Type: &#39;AWS::ApiGateway::UsagePlanKey&#39;
    Properties:
      KeyId: !Ref ApiKey
      KeyType: &#39;API_KEY&#39;
      UsagePlanId: !Ref UsagePlan
</code></pre><p>The section below creates the API path <code>installer</code>. It then creates the lambda function <code>ExampleAPIDependencies</code> which runs container image located in the image URI passed to the CloudFormation stack. As the container was built on an Apple Silicon Mac the architecture is specified as arm64. The lambda times out after 30 seconds and has a maximum memory of 500 Megabytes. The API gateway is then given permission to invoke the lambda function.</p>
<pre tabindex="0"><code># API Resource
  ApiResource:
    Type: &#39;AWS::ApiGateway::Resource&#39;
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: &#39;installer&#39;
      RestApiId: !Ref ApiGateway

  # The lambda function which is linked to the container image in the Elastic Container Registry
  ExampleAPIDependencies: 
    Type: &#34;AWS::Lambda::Function&#34;
    Properties:
      FunctionName: &#39;ExampleAPIDependencies&#39;
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ImageUri: !Ref ECRRepositoryUri
      PackageType: &#34;Image&#34;
      Architectures: 
        - &#39;arm64&#39;
      Timeout: 30
      MemorySize: 500

  # Gives the API Gateway permission to call the lambda function ExampleAPIDependencies
  LambdaApiGatewayPermission:
    Type: &#39;AWS::Lambda::Permission&#39;
    Properties:
      Action: &#39;lambda:InvokeFunction&#39;
      FunctionName: !Ref ExampleAPIDependencies
      Principal: &#39;apigateway.amazonaws.com&#39;
</code></pre><p>The lambda function is given permission to write to logs helping to monitor what happens when it is called. The ApiMethod specifies a GET command to call the API and that an API key is required. API deployment specifies when deployment happens.</p>
<pre tabindex="0"><code>
  # Lambda Execution Role
  LambdaExecutionRole:
    Type: &#39;AWS::IAM::Role&#39;
    Properties:
      AssumeRolePolicyDocument:
        Version: &#39;2012-10-17&#39;
        Statement:
          - Effect: &#39;Allow&#39;
            Principal:
              Service: &#39;lambda.amazonaws.com&#39;
            Action: &#39;sts:AssumeRole&#39;
      Policies:
        - PolicyName: &#39;LambdaBasicExecution&#39;
          PolicyDocument:
            Version: &#39;2012-10-17&#39;
            Statement:
              - Effect: &#39;Allow&#39;
                Action:
                  - &#39;logs:CreateLogGroup&#39;
                  - &#39;logs:CreateLogStream&#39;
                  - &#39;logs:PutLogEvents&#39;
                Resource: &#39;*&#39;
    
  # API Method
  ApiMethod:
    Type: &#39;AWS::ApiGateway::Method&#39;
    Properties:
      HttpMethod: &#39;GET&#39;
      ResourceId: !Ref ApiResource
      RestApiId: !Ref ApiGateway
      AuthorizationType: &#39;NONE&#39;
      ApiKeyRequired: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: &#39;POST&#39;
        Uri: !Sub &#39;arn:aws:apigateway:eu-west-2:lambda:path/2015-03-31/functions/${ExampleAPIDependencies.Arn}/invocations&#39;
  
  # API Deployment linked to a stage
  ApiDeployment:
    Type: &#39;AWS::ApiGateway::Deployment&#39;
    DependsOn: ApiMethod  # Ensures the deployment happens after the method is created
    Properties:
      RestApiId: !Ref ApiGateway
      StageName: !Sub &#39;${StageName}&#39;
</code></pre><h3 id="4-generating-an-api-key-that-rate-limits-the-api">4. Generating an API key that rate limits the API<a hidden class="anchor" aria-hidden="true" href="#4-generating-an-api-key-that-rate-limits-the-api">#</a></h3>
<p>To make it harder for someone unwanted to hit the API endpoint a large number of times racking up a bill, the CloudFormation template includes a rate limit plan. In the template an API key is generated here called &lsquo;APIExampleKey&rsquo; which is then attached to the plan. This does not ensure that the identity of the user of the API key is authenticated which would require additional steps.</p>
<pre tabindex="0"><code>  # Usage Plan
  UsagePlan:
    Type: &#39;AWS::ApiGateway::UsagePlan&#39;
    DependsOn: ApiDeployment  # Ensures the usage plan is created after the deployment
    Properties:
      UsagePlanName: &#39;MyUsagePlan&#39;
      ApiStages:
        - ApiId: !Ref ApiGateway
          Stage: &#39;prod&#39;
      Throttle:
        BurstLimit: 100
        RateLimit: 50
      Quota:
        Limit: 1000
        Period: MONTH

  # API Key
  ApiKey:
    Type: &#39;AWS::ApiGateway::ApiKey&#39;
    Properties:
      Enabled: true
      Name: &#39;APIExampleKey&#39;

  # Usage Plan Key
  UsagePlanKey:
    Type: &#39;AWS::ApiGateway::UsagePlanKey&#39;
    Properties:
      KeyId: !Ref ApiKey
      KeyType: &#39;API_KEY&#39;
      UsagePlanId: !Ref UsagePl`
</code></pre><h3 id="5-launching-the-api">5. Launching the API<a hidden class="anchor" aria-hidden="true" href="#5-launching-the-api">#</a></h3>
<p>To create the stack and generate the API (here called <code>ExampleApiStack</code>) we run the following from the command line (The xxxxxxxxxxx being replaced by the AWS account id):</p>
<pre tabindex="0"><code>aws cloudformation create-stack --stack-name ExampleApiStack \
     --template-body file://api-lambda-example.yml \
     --region eu-west-2 \
     --capabilities CAPABILITY_IAM \
     --parameters \
            ParameterKey=ECRRepositoryUri,ParameterValue=xxxxxxxxxxx.dkr.ecr.eu-west-2.amazonaws.com/api_example_container:latest \
            ParameterKey=StageName,ParameterValue=‘prod’
</code></pre><p>Here the container that the lambda runs and the StageName (here prod) are passed to the template as parameters.</p>
<p>To obtain the stack info:</p>
<pre tabindex="0"><code>aws cloudformation describe-stacks --stack-name ExampleApiStack
</code></pre><p>An example of the output from this is below. Some account specific information has been removed.
<img alt="stack_info" loading="lazy" src="https://johnardavies.github.io/stack_info.png"></p>
<h3 id="6-calling-the-api">6. Calling the API<a hidden class="anchor" aria-hidden="true" href="#6-calling-the-api">#</a></h3>
<p>To get the information on the API endpoint that the CloudFormation stack has generated:</p>
<pre tabindex="0"><code>aws apigateway get-rest-apis
</code></pre><p>An example of what the command produces is shown below:
<img alt="api_info" loading="lazy" src="https://johnardavies.github.io/api_info.png">
This gives us the API id which we insert into the general endpoint form that the stack produces (shown below) to call it.</p>
<pre tabindex="0"><code>https://{api_id}.execute-api.eu-west-2.amazonaws.com/prod/installer?input={text_passed_to_api}
</code></pre><p>In this example the api_id is 8ijgbd265k. The API key value can be obtained from the API Gateway page on the AWS console.
<img alt="api_gateway" loading="lazy" src="https://johnardavies.github.io/api_gateway.png">
To test the API works we curl the endpoint passing the API key in the header <code>-H &quot;x-api-key:</code> and the input text in the endpoint (Some formatting issues initially threw the curl command on a Mac: Having curly quotes “ rather than straight quotes &quot; and having whitespace after the <code>\</code>.) :</p>
<pre tabindex="0"><code>curl -X GET &#34;https://8ijgbd265k.execute-api.eu-west-2.amazonaws.com/prod/installer?input=world&#34; \
  -H &#34;x-api-key: pqsJ6ObKmx1SxAN0cTlUCHKubRDxH2d5UPBeRsej&#34;
</code></pre><p>This produces the return:</p>
<pre tabindex="0"><code>{&#34;hello&#34;: &#34;world&#34;, &#34;numpy version&#34;: &#34;2.2.1&#34;, &#34;pandas version&#34;: &#34;2.2.3&#34;}
</code></pre><p>An example of what this looks like in the terminal is:
<img alt="curl_example" loading="lazy" src="https://johnardavies.github.io/curl_example.png">
To remove the API and its stack when it is no longer needed:</p>
<pre tabindex="0"><code>aws cloudformation delete-stack --stack-name ExampleApiStack
</code></pre><p><strong>A variant of the usual Cloud warning</strong> At time of writing the AWS Lambda free tier in the eu-west-2 region includes one million free requests per month and beyond that it costs $0.20 per 1M requests see <a href="https://aws.amazon.com/lambda/pricing/">https://aws.amazon.com/lambda/pricing/</a>. This means that, in principle, serverless should cost very little as long as the number of requests is low. In the example here it is probably significantly cheaper than having a virtual machine continuously running to handle the API calls. However, in the event of large number of requests, perhaps by someone maliciously calling the API many times and/or any data processing incurring high storage costs this might not be true. Until AWS implements the budget cap that everyone wants, as always, the costs of cloud services should be  monitored and services turned off when not used to avoid incurring unwanted costs.</p>
<h3 id="references">References:<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h3>
<p>AWS guidance on working with .zip file archives for Python Lambda functions
<a href="https://docs.aws.amazon.com/lambda/latest/dg/python-package.html">https://docs.aws.amazon.com/lambda/latest/dg/python-package.html</a></p>
<p>AWS guidance on deploying Python Lambda functions with container images
<a href="https://docs.aws.amazon.com/lambda/latest/dg/python-image.html#python-image-clients">https://docs.aws.amazon.com/lambda/latest/dg/python-image.html#python-image-clients</a></p>
<p>AWS guidance on creating and configuring API keys and usage plans with AWS CloudFormation
<a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-key-usage-plan-cfn.html">https://docs.aws.amazon.com/apigateway/latest/developerguide/api-key-usage-plan-cfn.html</a></p>
<p>Michael Hart (2020), Using container images with AWS Lambda
<a href="https://hichaelmart.medium.com/using-container-images-with-aws-lambda-7ffbd23697f1">https://hichaelmart.medium.com/using-container-images-with-aws-lambda-7ffbd23697f1</a></p>
<h3 id="previous-cloud-posts">Previous Cloud posts<a hidden class="anchor" aria-hidden="true" href="#previous-cloud-posts">#</a></h3>
<p><em><strong><a href="https://johnardavies.github.io/technical/cloud_intro/">Cloud 1: Introduction to launching a Virtual Machine in the Cloud</a></strong></em></p>
<p><em><strong><a href="https://johnardavies.github.io/technical/cloud_use/">Cloud 2: Getting started with using a Virtual Machine in the Cloud</a></strong></em></p>
<p><em><strong><a href="https://johnardavies.github.io/technical/docker_use/">Cloud 3: Docker and Jupyter notebooks in the Cloud</a></strong></em></p>
<p><em><strong><a href="https://johnardavies.github.io/technical/serverless/">Cloud 4: Using Serverless</a></strong></em></p>
<p><em><strong><a href="https://johnardavies.github.io/technical/front_end/">Cloud 5: Introduction to deploying an app with simple CI/CD</a></strong></em></p>
<p><em><strong><a href="https://johnardavies.github.io/technical/infrastructure/">Cloud 6: Introduction to Infrastructure as Code using CloudFormation</a></strong></em></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://johnardavies.github.io/tags/technical/">Technical</a></li>
      <li><a href="https://johnardavies.github.io/tags/digital/">Digital</a></li>
      <li><a href="https://johnardavies.github.io/tags/cloud/">Cloud</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://johnardavies.github.io/">John&#39;s Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
