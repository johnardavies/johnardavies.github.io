<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Cloud 4: Using Serverless | John&#39;s Site</title>
<meta name="keywords" content="technical, digital, cloud" />
<meta name="description" content="La Cabane Éclatée aux 4 Salles, Daniel Buren at the Gori collection
What is Serverless? In previous posts we spun up virtual machines to work in the cloud, but the cloud can also perform specific functions for us without us having to run any servers, so called serverless computing. The servers providing the services still exist, but they are managed by the cloud provider while we deal with the services directly.">
<meta name="author" content="John Davies">
<link rel="canonical" href="https://johnardavies.github.io/technical/serverless/" />
<link crossorigin="anonymous" href="https://johnardavies.github.io/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css" integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw&#43;W8mWdq36u97PLc=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="https://johnardavies.github.io/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://johnardavies.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://johnardavies.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://johnardavies.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://johnardavies.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://johnardavies.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.88.1" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-YJ821LVT08', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-YJ821LVT08"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-YJ821LVT08', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Cloud 4: Using Serverless" />
<meta property="og:description" content="La Cabane Éclatée aux 4 Salles, Daniel Buren at the Gori collection
What is Serverless? In previous posts we spun up virtual machines to work in the cloud, but the cloud can also perform specific functions for us without us having to run any servers, so called serverless computing. The servers providing the services still exist, but they are managed by the cloud provider while we deal with the services directly." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://johnardavies.github.io/technical/serverless/" />
<meta property="og:image" content="https://johnardavies.github.io/serverless_gori.jpg" /><meta property="article:section" content="technical" />
<meta property="article:published_time" content="2022-10-14T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-10-14T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://johnardavies.github.io/serverless_gori.jpg" />
<meta name="twitter:title" content="Cloud 4: Using Serverless"/>
<meta name="twitter:description" content="La Cabane Éclatée aux 4 Salles, Daniel Buren at the Gori collection
What is Serverless? In previous posts we spun up virtual machines to work in the cloud, but the cloud can also perform specific functions for us without us having to run any servers, so called serverless computing. The servers providing the services still exist, but they are managed by the cloud provider while we deal with the services directly."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Technicals",
      "item": "https://johnardavies.github.io/technical/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Cloud 4: Using Serverless",
      "item": "https://johnardavies.github.io/technical/serverless/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Cloud 4: Using Serverless",
  "name": "Cloud 4: Using Serverless",
  "description": "La Cabane Éclatée aux 4 Salles, Daniel Buren at the Gori collection\nWhat is Serverless? In previous posts we spun up virtual machines to work in the cloud, but the cloud can also perform specific functions for us without us having to run any servers, so called serverless computing. The servers providing the services still exist, but they are managed by the cloud provider while we deal with the services directly.",
  "keywords": [
    "technical", "digital", "cloud"
  ],
  "articleBody": "La Cabane Éclatée aux 4 Salles, Daniel Buren at the Gori collection\nWhat is Serverless? In previous posts we spun up virtual machines to work in the cloud, but the cloud can also perform specific functions for us without us having to run any servers, so called serverless computing. The servers providing the services still exist, but they are managed by the cloud provider while we deal with the services directly.\nThis has the advantage that we do not have to administer any servers (for example by setting up firewalls). We are also not charged for a continuously running server so there may be cost savings. On the other hand rather than do something quite general, and commmon to most cloud providers, like managing Linux servers, we have to use techniques that are more provider specific increasing the risk of lock-in. Working with functions triggered by events and separate services also introduces some complexity.\nDue to these and other issues it is probably true that serverless hasn’t taken off as much as previously anticipated. Nevertheless it felt worth learning something about it and unbundled cloud services in general. Partly just to make a conceptual switch to a different way of doing things, but also as my current and previous data science employers make some use of it.\nServerless example with AWS I decided to try a serverless approach to collect data from the Twitter API as a simple project to learn more about it. This involved a variety of components from Amazon Web Services (AWS):\n  Lambdas which are functions triggered by events\n  Simple Storage System (S3) which allows us to create buckets that can store objects. In this case the raw json that we are getting from the API calls.\n  DynamoDB which is a no-SQL database. This allows us to take the json data returned from the API calls and input it into a database.\n  CloudFormation A template for launching services in AWS which specifies the services that we want and the security permissions they have.\n  AWS Systems Manager Parameter Store A way to store configuration information and secrets.\n  We will use a lambda function to schedule regular calls to the Twitter API. The json returned from the API calls is written to the S3 bucket. This event triggers another lambda function which writes the json to the DynamoDB database. The systems manager is used to pass information from one lambda function to another.\nFollowing this requires an AWS account and probably some basic familiarity with the AWS console and services, particularly as there is a cost involved (see warning below). We cover:\n1. installing the tools used to manage the project\n2. the overall project structure and its two main parts\n3. deploying the project\n4. monitoring the project\n5. how the data collected can be seen in the AWS console\n6. removing the project\nThis is intended as a simple example to learn about serverless, rather than an optimised collection pipeline, if you have suggestions as to how it can be improved while keeping things relatively simple please let me know.\nA variant of the usual Cloud warning At time of writing the AWS Lambda free tier in the amazon zone eu-west-2 includes one million free requests per month and beyond that it costs $0.20 per 1M requests see https://aws.amazon.com/lambda/pricing/. This means that, in principle, serverless should cost very little as long as the number of requests is low. In the example here it is probably significantly cheaper than having a virtual machine continuously running to make the API calls. However, in the event of large number of requests, perhaps by accidentally getting a lambda function to call itself and/or incurring high data storage costs this might not be true. Until AWS implements the budget cap that everyone wants, as always, the costs of cloud services should be closely monitored and services turned off when not used to avoid incurring unwanted costs.\n1. Installing the tools used to manage the project To manage the data collection system we will use the Serverless framework and the AWS command line interface (CLI) to allow us to interact programmatically with the cloud. To install Serverless:\n$ npm install -g serverless This requires Node which if not already installed can be obtained from https://nodejs.org/en/. Details on how to install the AWS CLI are here.\nFor these to be usable you will need to link them to your AWS account.\nTo install the python packages we will be using in a serverless environment, we also need to install the Serverless plugin: serverless-python-requirements\n$ serverless plugin install -n serverless-python-requirements Although we are using the Serverless framework with AWS, we could also use it with another cloud platform that offers serverless services like Google Cloud or Microsoft Azure, the details of the implementation would though be different.\n2. The overall project structure and its two main parts The serverless project consists of two main parts:\n1. The CloudFormation template A yaml file (serverless.yml) that sets out the services we want to use, their security permissions and when lambda functions will be triggered.\n2. The Python handler script that defines the lambda functions This script (handler.py) creates the lambda functions that are triggered by events and does the work of collecting and storing the data.\nThese two files should be saved together in the project folder. Running:\n$ serverless create --template aws-python --path api_call_serverless will create a folder called api_call_serverless with blank templates for both (Using sls instead of serverless will also work). We cover the CloudFormation template and python script in turn.\n2.1 The CloudFormation template\nIn our example shown below this consists of 5 parts:\n Gives the name of the service the template is defining, the aws user/profile that can run it, the cloud provider details and the programming environment we are using (in this case Python 3.9) Defines the security permissions of the Identity Access Management (IAM) roles Defines the lambda functions and the events that trigger them Sets up the DynamoDB resources that are needed References the plugin needed for the Python libraries  # This CloudFormation file (serverless.yml) configures the resources and lambda functions used # Part 1: The service name, the cloud provider details and the profile that is allowed to run it. service: serverless-api-call-example provider: name: aws runtime: python3.9 profile: serverless_test_user region: eu-west-2 # Part 2: The IAM role statements iamRoleStatements: - Effect: Allow Action: - s3:PutObject - s3:GetObject Resource: - arn:aws:s3:::serverless-api-data-collection/* - Effect: Allow Action: - dynamodb:PutItem - dynamodb:GetItem - dynamodb:DescribeTable Resource: - arn:aws:dynamodb:eu-west-2:*:table/apicallstore - Effect: Allow Action: - ssm:GetParameters - ssm:PutParameter Resource: - arn:aws:ssm:eu-west-2:*:parameter/last_tweet_id # Part 3: The lambda functions and the events they are triggered by functions: # The function that calls the API every 30 minutes api_caller: handler: handler.api_caller events: - schedule: rate(30 minutes) # The function that writes to the database when an item is added to the named bucket write_to_db: handler: handler.write_to_db events: - s3: bucket: serverless-api-data-collection event: s3:ObjectCreated:* # Part 4: The resources that are used resources: Resources: apicallstore: Type: AWS::DynamoDB::Table Properties: TableName: apicallstore KeySchema: - AttributeName: id KeyType: HASH - AttributeName: written_at KeyType: RANGE AttributeDefinitions: - AttributeName: id AttributeType: N - AttributeName: written_at AttributeType: S ProvisionedThroughput: ReadCapacityUnits: 30 WriteCapacityUnits: 5 # Part 5 the dependencies that are used # The python requirements plugin is referenced so we can import python libraries plugins: - serverless-python-requirements The profile the template is linked to\nHere we have set up an IAM profile called serverless_test_user. If you omit the profile line that references this in the yaml and deploy it with administrator rights then the stack should launch as the administrator has all the required privileges. However, in general it is considered better to create a specific IAM profile with restricted privileges, so that in the event the profile is compromised and/or the profile accidentally trys to do something you’d rather it didn’t (e.g. spin up lots of expensive virtual machines) what it can do is restricted. The IAM roles that follow in the yaml enable the profile to do certain activities for the project within the scope of the permissions set up for the profile when it was created.\nTo link the serverless_test_user profile with the command line, take the associated key (k) and secret (s) generated when the profile is created and input them into the following where the XXXs are shown:\n$ serverless config credentials -p aws -k XXX -s XXX --profile serverless_test_user ` The IAM roles\nEach IAM role has the following format:\n Effect: In this case - what the effect of the IAM role is. Here it is to “Allow” the profile to do certain activities Action: The action that the role allows. We want the permissions granted to each resource to be the minimum needed. Here we can get and put objects into the S3 bucket and put items in the database and get and put information in the systems manager. Resource: This covers the resources that the action is allowed to effect. In this case the S3 bucket (serverless-api-data-collection) the DynamoDB table (apicallstore)and the systems manager variable (last_tweet_id) that we are using.  The lambda functions\nThe lambda functions are identified in the yaml by name of each function and the event it is triggered by. The two functions (which are defined in handler.py) are:\n api_caller which calls the Twitter API and is set to run every 30 minutes write_to_db which is triggered when the json file returned from the API call is added to the S3 bucket, which then writes the results to the database.  The Resources in this case the DynamoDB database. Here we provision a table called apicallstore, we have an id key and a range key which the data is sorted by and which we set to be the time the tweet was written to the database. We have a write capacity of 5 which represents 5 writes to the database per second, for an item up to 1 KB in size (A kilobyte being roughly a page of text - so should be close to a tweet and its metadata). We want to read in the data collected that we are writing incrementally so we have a larger read capacity.\nWe need to enable the importing of the Python libraries we are using (here the Twython library to make the API calls) using the plugin serverless-python-requirements. A python requirements.txt file with the dependencies should be saved to the project folder so that the plugin can find the packages to install. This can be generated from within a virtual environment with the project’s dependencies installed by running $ pip freeze  requirements.txt.\nThe requirements file (requirements.txt), the CloudFormation file (serverless.yml), the Python handler file (handler.py) and the Twitter authentification details (tweet_auth.py) are the four files in the project folder prior to deployment (which will generate some additional files). When the project is deployed these are zipped together and uploaded to an S3 bucket in your account so that AWS can run it.\n2.2 The Python handler script that defines the lambda functions\nThe Python script shown below specifies tha lambda functions. The functions have the event and context format which are the standard arguments for python lambdas. The event is the data that’s passed to the function upon execution and context provides information about the current execution environment. The Twitter authentification details are stored in a tweet_auth file which we import. Using the logging library we set up some logging to monitor the stack as it is triggered.\napi_caller This is the function that calls the Twitter API which is triggered at regular intervals as specified in the serverless.yml. It searches for the words contained in the Python list (search_terms). If the function can access the last Tweet id collected it uses this in the API call to get later tweets.\nwrite_to_db This function, which is triggered by the api_caller writing the json to an S3 bucket, takes the returned tweets, extracts the data we want (the last tweet id, labelled max_tweet_id) and then writes them tweet by tweet to DynamoDB which parses the json for us automatically along with the time the write was done. The last tweet id is written to the systems manager overwriting the previous value.\nDealing with the lack of state in serverless In serverless we do not have any record of state as such. Here this is an issue as we want to use the id of the last tweet that we have already collected so we can input into the next API call that is made later. As far as I can tell there isn’t a complete consenus on how to handle variables that we want to temporarily store. Here we store the value of the last tweet id to the Systems Manager with write_to_db, so that it can then be accessed by api_caller.\nimport logging import json import time import hashlib from datetime import datetime from decimal import Decimal from tweet_auth import * from twython import Twython from boto3.dynamodb.conditions import Key import boto3 # This python script (handler.py) specifies the lambda functions logger = logging.getLogger() logger.setLevel(logging.DEBUG) logger.info(\"The handler started\") # The words that we are searching the tweets for. This can be a python list. search_terms = [\"learning serverless\"] def api_caller(event, context): \"\"\" Calls the Twitter API using the value of the last tweet id where it exists \"\"\" twitter = Twython(APP_KEY, APP_SECRET, access_token=ACCESS_TOKEN) # Connect to systems manager ssm = boto3.client(\"ssm\", \"eu-west-2\") # Looks for the last tweet id saved and makes and API call with it as an input if available try: last_response_id = ssm.get_parameters(Names=[\"last_tweet_id\"]) logger.info(\"here is the id\" + str(last_response_id)) call_results = twitter_search( q=search_terms, result_type=\"recent\", count=\"100\", since_id=last_response_id ) except: logger.info(\"calls the API without using the value of the last tweet_id\") call_results = twitter.search(q=search_terms, result_type=\"recent\", count=\"100\") # Gets the date and time timestr = time.strftime(\"%Y%m%d-%H%M%S\") # Connect to s3 s3conn = boto3.client(\"s3\") # Upload the api call result to the bucket serverless-api-data-collection s3conn.put_object( Key=timestr + \".json\", Body=json.dumps(call_results), Bucket=\"serverless-api-data-collection\" ) response = {\"statusCode\": 200, \"body\": timestr} return response def write_to_db(event, context): \"\"\" Function that is triggered by a file being added to the S3 bucket. It extracts the json and puts it into database \"\"\" # Gets the bucket name bucket = event[\"Records\"][0][\"s3\"][\"bucket\"][\"name\"] # Gets the json file _name json_file_name = event[\"Records\"][0][\"s3\"][\"object\"][\"key\"] # Get the information on (and from) the file that has just been written to S3 logger.info(\"The bucket \" + bucket + \" has a new file\") logger.info(\"The new file is = \" + json_file_name) s3_client = boto3.client(\"s3\") json_object = s3_client.get_object(Bucket=bucket, Key=json_file_name) jsonFileReader = json_object[\"Body\"].read() # converts json into dictionary data_dict = json.loads(jsonFileReader, parse_float=Decimal) # extracts the value of the largest tweet id max_tweet_id = str(data_dict[\"search_metadata\"][\"max_id\"]) logger.info(\"This is the \" + str(max_tweet_id)) # Stores the value of the last tweet id to the systems manager ssm = boto3.client(\"ssm\", \"eu-west-2\") try: new_string_parameter = ssm.put_parameter( Name=\"last_tweet_id\", Description=\"the id of the last tweet collected\", Value=max_tweet_id, Type=\"String\", Overwrite=True, Tier=\"Standard\", DataType=\"text\", ) except: logger.info(\"saving the last tweet id failed\") # Connects to dynamodb and the table apicallstore dynamodb = boto3.resource(\"dynamodb\") table = dynamodb.Table(\"apicallstore\") # Loops through the items and write them one at a time to the table at the rate of 5 a second for item in data_dict[\"statuses\"]: # Adds a field to the json with when the data is being written item[\"written_at\"] = datetime.now().strftime(\"%m/%d/%Y, %H:%M:%S\") item[\"max_tweet_id\"] = max_tweet_id time.sleep(0.2) table.put_item(Item=item) response = {\"statusCode\": 200, \"body\": \"Items written\"} return response 3. Deploying the project To launch the stack from the folder that contains the CloudFormation template and python handler script we run:\n$ serverless deploy This should take a few minutes and result in something like the text below (some computer specific information has been removed). If we want to make some changes to update one of the functions, then this can be done in isolation and is much faster than redeploying the full serverless stack. In the case of updating the function write_to_db\n$ serverless deploy --function write_to_db It is also possible to run functions individually. This won’t work for write_to_db as it needs to have the event of a file being added to the bucket to be triggered, but we can run api_caller where the function is referenced by the -f (in long form –function) with:\n$ serverless invoke -f api_caller 4. Monitoring the project To see the logs relating to a given lambda function run the following with a reference for the associated lambda function, here write_to_db which is referenced by the -f beforehand:\n$ serverless logs -t -f write_to_db The -t tails the logs, printing the text output of new logs to the console as they are triggered.\nTo get the schema of the table:\n$ aws dynamodb describe-table --table-name apicallstore\n5. How the data collected can be seen in the AWS console To see the data in the AWS console, log into the console and go to DynamoDB under the Services tab, then navigate to the Tables tab.\nIf you click on the table name apicallstore and then the Explore Table Items on the next page you will be directed to a page where you can see the data in the DynamoDB table.\nIf the stack is deployed and looks as if it is working, but nothing is visible check that the page is being viewed for the same amazon region that you created the stack in. Here this is in London (eu-west-2) as shown in the top right-hand corner.\n6. Removing the project If we want to stop collecting data, then the stack can be removed.\n$ serverless remove Depending on the access restrictions this command may not remove the data from the buckets. If you have permissions they can be deleted using the below, but be sure to give the name of the correct S3 bucket before you run it\n$ aws s3 rm s3://bucket-name --recursive\nThe stack can also be removed by going to CloudFormation through the Services tab of the AWS console, navigating to the Stacks button and deleting the stack via the menu as illustrated below. Previous cloud posts: Cloud 1: Introduction to launching a Virtual Machine in the Cloud\nCloud 2: Getting started with using a Virtual Machine in the Cloud\nCloud 3: Docker and Jupyter notebooks in the Cloud\nCloud 5: Introduction to deploying an app with simple CI/CD\nReferences\nDan Frost, ‘Serverless: Deploy on AWS’, Linux Format 2019 Annual\nAndreas and Michael Wittig, ‘Amazon Web Services in action, 2nd edition’, Manning.\nAnomaly Innovations, ‘Serverless Stack’\n",
  "wordCount" : "3069",
  "inLanguage": "en",
  "image":"https://johnardavies.github.io/serverless_gori.jpg","datePublished": "2022-10-14T00:00:00Z",
  "dateModified": "2022-10-14T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "John Davies"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://johnardavies.github.io/technical/serverless/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "John's Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://johnardavies.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://johnardavies.github.io/" accesskey="h" title="John&#39;s Site (Alt + H)">John&#39;s Site</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://johnardavies.github.io/creative_industries" title="creative industries">
                    <span>creative industries</span>
                </a>
            </li>
            <li>
                <a href="https://johnardavies.github.io/other_data_projects" title="other data projects">
                    <span>other data projects</span>
                </a>
            </li>
            <li>
                <a href="https://johnardavies.github.io/talks/" title="talks">
                    <span>talks</span>
                </a>
            </li>
            <li>
                <a href="https://johnardavies.github.io/technical/" title="technical">
                    <span>technical</span>
                </a>
            </li>
            <li>
                <a href="https://johnardavies.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://johnardavies.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Cloud 4: Using Serverless
    </h1>
    <div class="post-meta">October 14, 2022&nbsp;·&nbsp;John Davies
</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://johnardavies.github.io/serverless_gori.jpg" alt="">
        
</figure>
  <div class="post-content"><p><em>La Cabane Éclatée aux 4 Salles, Daniel Buren at <a href="http://www.goricoll.it/">the Gori collection</a></em></p>
<h3 id="what-is-serverless">What is Serverless?<a hidden class="anchor" aria-hidden="true" href="#what-is-serverless">#</a></h3>
<p>In previous posts we spun up virtual machines to work in the cloud, but the cloud can also
perform specific functions for us without us having to run any servers, so called serverless computing. The servers providing the services still exist, but they are managed by the cloud provider while we deal with the services directly.</p>
<p>This has the advantage that we do not have to administer any servers (for example by setting up firewalls). We are also not charged for a continuously running server so there may be cost savings. On the other hand rather than do something quite general, and commmon to most cloud providers, like  managing Linux servers, we have to use techniques that
are more provider specific increasing the risk of lock-in. Working with functions triggered by events and separate services also introduces some complexity.</p>
<p>Due to these and other issues it is probably true that serverless hasn&rsquo;t taken off as much as previously <a href="https://www.infoq.com/articles/serverless-stalled/">anticipated</a>.
Nevertheless it felt worth learning something about it and unbundled cloud services in general. Partly just to make a conceptual switch to a different way of doing things, but also as my current and previous data science employers make some use of it.</p>
<h3 id="serverless-example-with-aws">Serverless example with AWS<a hidden class="anchor" aria-hidden="true" href="#serverless-example-with-aws">#</a></h3>
<p>I decided to try a serverless approach to collect data from the Twitter API as a simple project to learn more about it.
This involved a variety of components from Amazon Web Services (AWS):</p>
<ul>
<li>
<p><strong>Lambdas</strong> which are functions triggered by events</p>
</li>
<li>
<p><strong>Simple Storage System (S3)</strong> which allows us to create buckets that can store objects. In this case the raw json that we are getting from the API calls.</p>
</li>
<li>
<p><strong>DynamoDB</strong> which is a no-SQL database. This allows us to take the json data returned from the API calls and input it into a database.</p>
</li>
<li>
<p><strong>CloudFormation</strong> A template for launching services in AWS which specifies the services that we want and the security permissions they have.</p>
</li>
<li>
<p><strong>AWS Systems Manager Parameter Store</strong> A way to store configuration information and secrets.</p>
</li>
</ul>
<p><img loading="lazy" src="https://johnardavies.github.io/aws_schematic.png" alt="Schematic"  />
</p>
<p>We will use a lambda function to schedule regular calls to the Twitter API. The json returned from the API calls is written to the S3 bucket. This event triggers another lambda function which writes the json to the DynamoDB database. The systems manager is used to pass information from one lambda function to another.</p>
<p>Following this requires an AWS account and probably some basic familiarity with the AWS console and services, particularly as there is a cost involved (see warning below).
We cover:<br>
<strong>1. installing the tools used to manage the project</strong><br>
<strong>2. the overall project structure and its two main parts</strong><br>
<strong>3. deploying the project</strong><br>
<strong>4. monitoring the project</strong><br>
<strong>5. how the data collected can be seen in the AWS console</strong><br>
<strong>6. removing the project</strong></p>
<p>This is intended as a simple example to learn about serverless, rather than an optimised collection pipeline, if you have suggestions as to how it can be improved while keeping things relatively simple please let me know.</p>
<p><em><strong>A variant of the usual Cloud warning</strong></em>
At time of writing the AWS Lambda free tier in the amazon zone eu-west-2 includes one million free requests per month and beyond that it costs $0.20 per 1M requests
see <a href="https://aws.amazon.com/lambda/pricing/">https://aws.amazon.com/lambda/pricing/</a>. This means that, in principle, serverless should cost very little
as long as the number of requests is low. In the example here it is probably significantly cheaper than having a virtual machine continuously running to make the API calls. However, in the event of large number of requests, perhaps by accidentally getting a lambda function to call itself and/or incurring high data storage costs this might not be true. Until AWS implements the budget cap that everyone wants, as always, the costs of cloud services should be closely monitored and services turned off when not used to avoid incurring unwanted costs.</p>
<h3 id="1-installing-the-tools-used-to-manage-the-project">1. Installing the tools used to manage the project<a hidden class="anchor" aria-hidden="true" href="#1-installing-the-tools-used-to-manage-the-project">#</a></h3>
<p>To manage the data collection system we will use the <a href="https://www.serverless.com/framework/docs">Serverless framework</a> and the AWS command line interface (CLI) to allow us to interact programmatically with the cloud.
To install Serverless:</p>
<pre tabindex="0"><code>$ npm install -g serverless
</code></pre><p>This requires Node which if not already installed can be obtained from <a href="https://nodejs.org/en/">https://nodejs.org/en/</a>.
Details on how to install the AWS CLI are <a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html">here</a>.<br>
For these to be usable you will need to link them to your AWS account.</p>
<p>To install the python packages we will be using in a serverless environment, we also need to install the Serverless plugin: serverless-python-requirements</p>
<pre tabindex="0"><code>$ serverless plugin install -n serverless-python-requirements
</code></pre><p>Although we are using the Serverless framework with AWS, we could also use it with another cloud platform that offers serverless services like Google Cloud or Microsoft Azure,
the details of the implementation would though be different.</p>
<h3 id="2-the-overall-project-structure-and-its-two-main-parts">2. The overall project structure and its two main parts<a hidden class="anchor" aria-hidden="true" href="#2-the-overall-project-structure-and-its-two-main-parts">#</a></h3>
<p>The serverless project consists of two main parts:</p>
<p><em><strong>1. The CloudFormation template</strong></em> A yaml file (<code>serverless.yml</code>) that sets out the services we want to use, their security permissions and when lambda functions will be triggered.</p>
<p><em><strong>2. The Python handler script that defines the lambda functions</strong></em> This script (<code>handler.py</code>) creates the lambda functions that are triggered by events and does the work of collecting and storing the data.</p>
<p>These two files should be saved together in the project folder. Running:</p>
<pre tabindex="0"><code>$ serverless create --template aws-python --path api_call_serverless
</code></pre><p>will create a folder called api_call_serverless with blank templates for both (Using sls instead of serverless will also work). We cover the CloudFormation template and python script in turn.</p>
<p><strong>2.1 The CloudFormation template</strong></p>
<p>In our example shown below this consists of 5 parts:</p>
<ol>
<li><em>Gives the name of the service the template is defining, the aws user/profile that can run it, the cloud provider details and the programming environment we are using (in this case Python 3.9)</em></li>
<li><em>Defines the security permissions of the Identity Access Management (IAM) roles</em></li>
<li><em>Defines the lambda functions and the events that trigger them</em></li>
<li><em>Sets up the DynamoDB resources that are needed</em></li>
<li><em>References the plugin needed for the Python libraries</em></li>
</ol>
<pre tabindex="0"><code># This CloudFormation file (serverless.yml) configures the resources and lambda functions used

# Part 1: The service name, the cloud provider details and the profile that is allowed to run it.

service: serverless-api-call-example
provider:
  name: aws
  runtime: python3.9
  profile: serverless_test_user
  region: eu-west-2

# Part 2: The IAM role statements

  iamRoleStatements:
    - Effect: Allow
      Action:
       - s3:PutObject
       - s3:GetObject
      Resource: 
       - arn:aws:s3:::serverless-api-data-collection/*
    - Effect: Allow
      Action:
        - dynamodb:PutItem
        - dynamodb:GetItem
        - dynamodb:DescribeTable
      Resource: 
       - arn:aws:dynamodb:eu-west-2:*:table/apicallstore
    - Effect: Allow
      Action:
        - ssm:GetParameters
        - ssm:PutParameter
      Resource:
        - arn:aws:ssm:eu-west-2:*:parameter/last_tweet_id
      
# Part 3: The lambda functions and the events they are triggered by

functions:

# The function that calls the API every 30 minutes
  api_caller:
    handler: handler.api_caller
    events:
     - schedule: rate(30 minutes)

# The function that writes to the database when an item is added to the named bucket
  write_to_db:
    handler: handler.write_to_db
    events:
      - s3:
          bucket: serverless-api-data-collection
          event: s3:ObjectCreated:*

# Part 4: The resources that are used

resources:
 Resources:
    apicallstore:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: apicallstore
        KeySchema:
           - AttributeName: id
             KeyType: HASH
           - AttributeName: written_at
             KeyType: RANGE
        AttributeDefinitions:
           - AttributeName: id
             AttributeType: N
           - AttributeName: written_at 
             AttributeType: S
        ProvisionedThroughput:
          ReadCapacityUnits: 30
          WriteCapacityUnits: 5                   

# Part 5 the dependencies that are used
# The python requirements plugin is referenced so we can import python libraries 
plugins:
  - serverless-python-requirements
</code></pre><p><strong>The profile the template is linked to</strong><br>
Here we have set up an IAM profile called <code>serverless_test_user</code>. If you omit the profile line that references this in the yaml and deploy it with administrator rights then the stack should launch as the administrator has all the required privileges. However, in general it is considered better to create a specific IAM profile with restricted privileges, so that in the event the profile is compromised and/or the profile accidentally trys to do something you&rsquo;d rather it didn&rsquo;t (e.g. spin up lots of expensive virtual machines) what it can do is restricted. The IAM roles that follow in the yaml enable the profile to do certain activities for the project within the scope of the permissions set up for the profile when it was created.</p>
<p>To link the <code>serverless_test_user</code> profile with the command line, take the associated key (k) and secret (s) generated when the profile is created and input them into the following where the XXXs are shown:</p>
<pre tabindex="0"><code>$ serverless config credentials -p aws -k XXX -s XXX --profile serverless_test_user                                                               `
</code></pre><p><em><strong>The IAM roles</strong></em><br>
Each IAM role has the following format:</p>
<ol>
<li><strong>Effect</strong>: In this case - what the effect of the IAM role is. Here it is to &ldquo;Allow&rdquo; the profile to do certain activities</li>
<li><strong>Action</strong>: The action that the role allows. We want the permissions granted to each resource to be the minimum needed. Here we can get and put objects into the S3 bucket and put items in the database and get and put information in the systems manager.</li>
<li><strong>Resource</strong>: This covers the resources that the action is allowed to effect. In this case the S3 bucket <code>(serverless-api-data-collection)</code> the DynamoDB table <code>(apicallstore)</code>and the systems manager variable <code>(last_tweet_id)</code> that we are using.</li>
</ol>
<p><em><strong>The lambda functions</strong></em><br>
The lambda functions are identified in the yaml by name of each function and the event it is triggered by. The two functions (which are defined in handler.py) are:</p>
<ul>
<li><em><strong>api_caller</strong></em> which calls the Twitter API and is set to run every 30 minutes</li>
<li><em><strong>write_to_db</strong></em> which is triggered when the json file returned from the API call is added to the S3 bucket, which then writes the results to the database.</li>
</ul>
<p>The <em><strong>Resources</strong></em> in this case the DynamoDB database. Here we provision a table called <code>apicallstore</code>, we have an id key and a range key which the data is sorted by and which we set to be the time the tweet was written to the database.
We have a write capacity of 5 which represents 5 writes to the database per second, for an item up to 1 KB in size (A kilobyte being roughly a page of text - so should be close to a tweet and its metadata).
We want to read in the data collected that we are writing incrementally so we have a larger read capacity.</p>
<p>We need to enable the importing of the Python libraries we are using (here the Twython library to make the API calls) using the plugin <code>serverless-python-requirements</code>.
A python requirements.txt file with the dependencies should be saved to the project folder so that the plugin can find the packages to install. This can be generated from within a virtual environment with the project&rsquo;s dependencies installed by running <code>$ pip freeze &gt; requirements.txt</code>.</p>
<p>The requirements file (<code>requirements.txt</code>), the CloudFormation file (<code>serverless.yml</code>), the Python handler file (<code>handler.py</code>) and the Twitter authentification details (<code>tweet_auth.py</code>) are the four files in the project folder prior to deployment (which will generate some additional files). When the project is deployed these are zipped together and uploaded to an S3 bucket in your account  so that AWS can run it.</p>
<p><strong>2.2  The Python handler script that defines the lambda functions</strong></p>
<p>The Python script shown below specifies tha lambda functions. The functions have the event and context format which are the standard arguments for python lambdas. The <code>event</code> is the data that&rsquo;s passed to the function upon execution and <code>context</code> provides information about the current execution environment.
The Twitter authentification details are stored in a tweet_auth file which we import. Using the logging library we set up some logging to monitor the stack as it is triggered.</p>
<p><strong>api_caller</strong> This is the function that calls the Twitter API which is triggered at regular intervals as specified in the serverless.yml. It searches for the words contained in the Python list (<code>search_terms</code>). If the function can access the last Tweet id collected it uses this in the API call to
get later tweets.</p>
<p><strong>write_to_db</strong> This function, which is triggered by the api_caller writing the json to an S3 bucket, takes the returned tweets, extracts the data we want (the last tweet id, labelled <code>max_tweet_id</code>) and then writes them tweet by tweet to DynamoDB which parses the json for us automatically along with the time the write was done.
The last tweet id is written to the systems manager overwriting the previous value.</p>
<p><em>Dealing with the lack of state in serverless</em>
In serverless we do not have any record of state as such. Here this is an issue as we want to use the id of the last tweet that we have already collected so we can input into the next API call that is made later.
As far as I can tell there isn&rsquo;t a complete consenus on how to handle variables that we want to temporarily store. Here we store the value of the last tweet id to the Systems Manager with <code>write_to_db</code>, so that it can then be accessed by <code>api_caller</code>.</p>
<pre tabindex="0"><code>import logging
import json
import time
import hashlib
from datetime import datetime
from decimal import Decimal
from tweet_auth import *
from twython import Twython
from boto3.dynamodb.conditions import Key
import boto3

# This python script (handler.py) specifies the lambda functions

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
logger.info(&quot;The handler started&quot;)


# The words that we are searching the tweets for. This can be a python list.
search_terms = [&quot;learning serverless&quot;]


def api_caller(event, context):
    &quot;&quot;&quot;
    Calls the Twitter API using the value of the last tweet id where it exists
    &quot;&quot;&quot;
    twitter = Twython(APP_KEY, APP_SECRET, access_token=ACCESS_TOKEN)

    # Connect to systems manager
    ssm = boto3.client(&quot;ssm&quot;, &quot;eu-west-2&quot;)
    # Looks for the last tweet id saved and makes and API call with it as an input if available
    try:
        last_response_id = ssm.get_parameters(Names=[&quot;last_tweet_id&quot;])
        logger.info(&quot;here is the id&quot; + str(last_response_id))
        call_results = twitter_search(
            q=search_terms, result_type=&quot;recent&quot;, count=&quot;100&quot;, since_id=last_response_id
        )  
    except:
        logger.info(&quot;calls the API without using the value of the last tweet_id&quot;)
        call_results = twitter.search(q=search_terms, result_type=&quot;recent&quot;, count=&quot;100&quot;)
    # Gets the date and time
    timestr = time.strftime(&quot;%Y%m%d-%H%M%S&quot;)
    # Connect to s3
    s3conn = boto3.client(&quot;s3&quot;)
    # Upload the api call result to the bucket serverless-api-data-collection
    s3conn.put_object(
        Key=timestr + &quot;.json&quot;,
        Body=json.dumps(call_results),
        Bucket=&quot;serverless-api-data-collection&quot;
     )

    response = {&quot;statusCode&quot;: 200, &quot;body&quot;: timestr}
    return response



def write_to_db(event, context):
    &quot;&quot;&quot;
    Function that is triggered by a file being added to the S3 bucket. It extracts the json and puts it into database
    &quot;&quot;&quot;

    # Gets the bucket name
    bucket = event[&quot;Records&quot;][0][&quot;s3&quot;][&quot;bucket&quot;][&quot;name&quot;]
    # Gets the json file _name
    json_file_name = event[&quot;Records&quot;][0][&quot;s3&quot;][&quot;object&quot;][&quot;key&quot;]

    # Get the information on (and from) the file that has just been written to S3
    logger.info(&quot;The bucket &quot; + bucket + &quot; has a new file&quot;)
    logger.info(&quot;The new file is = &quot; + json_file_name)
    s3_client = boto3.client(&quot;s3&quot;)
    json_object = s3_client.get_object(Bucket=bucket, Key=json_file_name)
    jsonFileReader = json_object[&quot;Body&quot;].read()

    # converts json into dictionary
    data_dict = json.loads(jsonFileReader, parse_float=Decimal)
    # extracts the value of the largest tweet id
    max_tweet_id = str(data_dict[&quot;search_metadata&quot;][&quot;max_id&quot;])
    logger.info(&quot;This is the &quot; + str(max_tweet_id))

    # Stores the value of the last tweet id to the systems manager
    ssm = boto3.client(&quot;ssm&quot;, &quot;eu-west-2&quot;)
    try:
        new_string_parameter = ssm.put_parameter(
            Name=&quot;last_tweet_id&quot;,
            Description=&quot;the id of the last tweet collected&quot;,
            Value=max_tweet_id,
            Type=&quot;String&quot;,
            Overwrite=True,
            Tier=&quot;Standard&quot;,
            DataType=&quot;text&quot;,
        )
    except:
        logger.info(&quot;saving the last tweet id failed&quot;)

    # Connects to dynamodb and the table apicallstore
    dynamodb = boto3.resource(&quot;dynamodb&quot;)
    table = dynamodb.Table(&quot;apicallstore&quot;)


    # Loops through the items and write them one at a time to the table at the rate of 5 a second
    for item in data_dict[&quot;statuses&quot;]:
        # Adds a field to the json with when the data is being written
        item[&quot;written_at&quot;] = datetime.now().strftime(&quot;%m/%d/%Y, %H:%M:%S&quot;)
        item[&quot;max_tweet_id&quot;] = max_tweet_id
        time.sleep(0.2)
        table.put_item(Item=item)
    response = {&quot;statusCode&quot;: 200, &quot;body&quot;: &quot;Items written&quot;}

    return response

</code></pre><h3 id="3-deploying-the-project">3. Deploying the project<a hidden class="anchor" aria-hidden="true" href="#3-deploying-the-project">#</a></h3>
<p>To launch the stack from the folder that contains the CloudFormation template and python handler script we run:</p>
<pre tabindex="0"><code>$ serverless deploy
</code></pre><p>This should take a few minutes and result in something like the text below (some computer specific information has been removed).
<img loading="lazy" src="https://johnardavies.github.io/Deploy.png" alt="Deploy"  />

If we want to make some changes to update one of the functions, then this can be done in isolation and is much faster than redeploying the full serverless stack. In the case of updating the function <code>write_to_db</code></p>
<pre tabindex="0"><code>$ serverless deploy --function write_to_db
</code></pre><p>It is also possible to run functions individually. This won&rsquo;t work for <code>write_to_db</code> as it needs to have the event of a file being added to the bucket to be triggered, but we can run <code>api_caller</code>
where the function is referenced by the -f (in long form &ndash;function) with:</p>
<pre tabindex="0"><code>$ serverless invoke -f api_caller
</code></pre><h3 id="4-monitoring-the-project">4. Monitoring the project<a hidden class="anchor" aria-hidden="true" href="#4-monitoring-the-project">#</a></h3>
<p>To see the logs relating to a given lambda function run the following with a reference for the associated lambda function, here <code>write_to_db</code> which is referenced by the -f beforehand:</p>
<pre tabindex="0"><code>$ serverless logs -t -f write_to_db
</code></pre><p>The -t tails the logs, printing the text output of new logs to the console as they are triggered.</p>
<p>To get the schema of the table:<br>
<code>$ aws dynamodb describe-table --table-name apicallstore</code></p>
<h3 id="5-how-the-data-collected-can-be-seen-in-the-aws-console">5. How the data collected can be seen in the AWS console<a hidden class="anchor" aria-hidden="true" href="#5-how-the-data-collected-can-be-seen-in-the-aws-console">#</a></h3>
<p>To see the data in the AWS console, log into the console and go to DynamoDB under the Services tab, then navigate to the Tables tab.</p>
<p><img loading="lazy" src="https://johnardavies.github.io/dynamodb.png" alt="Dynamo"  />

If you click on the table name apicallstore and then the <em><strong>Explore Table Items</strong></em> on the next page you will be directed to a page where you can see the data in the DynamoDB table.</p>
<p><img loading="lazy" src="https://johnardavies.github.io/the_data_2.png" alt="The_data"  />
</p>
<p>If the stack is deployed and looks as if it is working, but nothing is visible check that the page is being viewed for the same amazon region that you created the stack in.
Here this is in London (eu-west-2) as shown in the top right-hand corner.</p>
<h3 id="6-removing-the-project">6. Removing the project<a hidden class="anchor" aria-hidden="true" href="#6-removing-the-project">#</a></h3>
<p>If we want to stop collecting data, then the stack can be removed.</p>
<pre tabindex="0"><code>$ serverless remove
</code></pre><p>Depending on the access restrictions this command may not remove the data from the buckets. If you have permissions they can be deleted using the below, but be sure to give the name of the correct S3 bucket before you run it<br>
<code>$ aws s3 rm s3://bucket-name --recursive</code></p>
<p>The stack can also be removed by going to CloudFormation through the Services tab of the AWS console, navigating to the Stacks button and deleting the stack via the menu as illustrated below.
<img loading="lazy" src="https://johnardavies.github.io/Deleting_stack.png" alt="Stack_removal"  />
</p>
<h3 id="previous-cloud-posts">Previous cloud posts:<a hidden class="anchor" aria-hidden="true" href="#previous-cloud-posts">#</a></h3>
<p><em><strong><a href="https://johnardavies.github.io/technical/cloud_intro/">Cloud 1: Introduction to launching a Virtual Machine in the Cloud</a></strong></em></p>
<p><em><strong><a href="https://johnardavies.github.io/technical/cloud_use/">Cloud 2: Getting started with using a Virtual Machine in the Cloud</a></strong></em></p>
<p><em><strong><a href="https://johnardavies.github.io/technical/docker_use/">Cloud 3: Docker and Jupyter notebooks in the Cloud</a></strong></em></p>
<p><em><strong><a href="https://johnardavies.github.io/technical/front_end/">Cloud 5: Introduction to deploying an app with simple CI/CD</a></strong></em></p>
<p><em><strong>References</strong></em></p>
<p>Dan Frost, &lsquo;Serverless: Deploy on AWS&rsquo;, Linux Format  2019 Annual</p>
<p>Andreas and Michael Wittig, ‘Amazon Web Services in action, 2nd edition’, Manning.</p>
<p>Anomaly Innovations, <a href="https://sst.dev/#guide">&lsquo;Serverless Stack&rsquo;</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://johnardavies.github.io/tags/technical/">technical</a></li>
      <li><a href="https://johnardavies.github.io/tags/digital/">digital</a></li>
      <li><a href="https://johnardavies.github.io/tags/cloud/">cloud</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://johnardavies.github.io/">John&#39;s Site</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
